


# count = int(input())
# word_set = set()
# for _ in range(count):
#     word = input()
#     word_set.add(word)

# word_li = list(word_set)

# output_li = []

# for index in range(len(word_li)):
#     if len(word_li[index])

"""
この問題は、アルファベット小文字で構成された複数の単語を特定のルールに従って並べ替えることを要求しています。具体的には、以下の条件を満たすように単語を並べ替えます：

1. 単語の長さが短い順
2. 長さが同じ場合は辞書順
3. 重複した単語は一つだけ残す

### 解法のステップ

1. **入力の処理**：
   - 最初の行で単語の数 `N` を読み込みます。
   - 次の `N` 行で単語を読み込みます。

2. **重複の除去**：
   - 重複する単語を除去します。これには集合（`set`）を使うと便利です。

3. **並べ替え**：
   - 単語の長さと辞書順に従って並べ替えます。Pythonの組み込み関数 `sorted()` を使い、カスタムのキーを指定します。

4. **出力**：
   - 並べ替えた単語を一行ずつ出力します。

### 実装例

```python
# 入力を受け取る
import sys
input = sys.stdin.read
data = input().split()

N = int(data[0])
words = list(set(data[1:]))

# 単語を条件に従ってソートする
words.sort(key=lambda x: (len(x), x))

# 結果を出力する
for word in words:
    print(word)
```

### 詳細説明

1. **入力の処理**：
   - 標準入力からデータを読み込み、最初の要素を単語数 `N` として扱い、それ以降の要素を単語リストとして扱います。
   - `set` を使って重複を除去し、リストに戻します。

2. **ソート**：
   - `sorted()` 関数に `key` パラメータを渡し、単語の長さと単語そのもののタプル `(len(x), x)` に基づいてソートします。
   - これにより、単語の長さが優先され、同じ長さの場合は辞書順で並べ替えられます。

3. **出力**：
   - ソートされた単語リストを一行ずつ出力します。

このアプローチにより、効率的に単語を並べ替え、要求された出力を得ることができます。`N` が20,000以下であり、各単語の長さが50以下なので、この方法はパフォーマンス的にも問題ありません。
"""